<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>TranslationEngine by King-AK</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">TranslationEngine</h1>
      <h2 class="project-tagline">Magically converts JSON files to test cases</h2>
      <a href="https://github.com/King-AK/TranslationWMcs435" class="btn">View on GitHub</a>
      <a href="https://github.com/King-AK/TranslationWMcs435/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/King-AK/TranslationWMcs435/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p><strong><p> College of William and Mary -- CSCI 435 -- TranslationTeam </p></strong></p>

<p> TranslationTeam members: Nathan Chen, Avon Davey, Mark Hutchens, Tho Tran</p>

<h1>
<a id="purpose" class="anchor" href="#purpose" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Purpose</h1>

<hr>

<p>
The TranslationEngine project was carried out by the TranslationTeam during the Spring 2016 semester at the College of William and Mary as part of the coursework for instructor Denys Poshyvanyk's CSCI 435 course under the supervision of teaching assistant Carlos Bernal-Cardenas. This project aims to automatically generate test cases for various Android graphical user interface (GUI) testing frameworks.
</p>

<p>
Testing software is an important task of software engineering because it assures the quality of the systems that users will use. Moreover, there are different metrics that help to identify whether a software is ready to go to production after executing different tests. In particular for Android applications there are several testing frameworks (e.g. Robotium, Robolectric) that help generate test cases in order to improve the quality of Android applications. However different these frameworks may seem, they are all being used (at least by us) to run automated tests on the same type of graphical interface. Knowing this, we are able to make use of test cases which are more generally described as GUI events in JSON files rather than explicit code for specific frameworks.
</p>

<p>
Therefore, the goal of this project is to generate a translation engine that will take as input a JSON file containing GUI events, and then parse those events into Java code which is executable for several different testing frameworks.
</p>

<h1>
<a id="video-demo" class="anchor" href="#video-demo" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Video Demo</h1>

<p><a href="https://vimeo.com/3514904" title="Little red riding hood - Click to Watch!"><img src="http://i.imgur.com/7YTMFQp.png" alt="Little red ridning hood"></a></p>

<h1>
<a id="project-overview" class="anchor" href="#project-overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Project Overview</h1>

<h2>
<a id="user-guide" class="anchor" href="#user-guide" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>User Guide</h2>

<p>The purpose of the program is to parse a JSON file into a usable Android testing framework.</p>

<p>It's fairly easy to use the program. Run the program with command line prompts, with a preference file passed as the first parameter, or type in parameters with a prompt.  The prompt is self-explanatory. You can type the numbers, or you can type the name of the framework (Case-sensitive at the moment. Easy to change). Input and output files require "./IO/" at the front if you have them saved in the IO folder! (I could also make that flexible, but then absolute path would be harder to use.)</p>

<p>The command-line uses the same ordering as the prompter: Framework, Mode ("file"/"live"), Input, Output. e.g. "UIAutomator file ./IO/mileage_swipe.txt ./IO/standard_out.txt" without the quotes.</p>

<p>If you want to use a preference file, pass in a single parameter, your preference file's name. Your file must end with ".txt" which is how we're telling the difference between this and directly plugging in your commands.</p>

<p>The only live mode actually integrated at the moment is Appium. For all file modes, you will need to copy-paste the outputted code into your preexisting test framework. A list of required items on a per-framework basis could be added to meet demand.</p>

<h2>
<a id="supported-frameworks" class="anchor" href="#supported-frameworks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Supported frameworks</h2>

<p>TranslationEngine currently supports the following testing frameworks: Appium, Espresso, Robolectric (soon), Robotium, UIAutomator</p>

<hr>

<p>Appium is a black box testing framework. It sets up a server that controls your Android device/emulator remotely to perform live testing. It doesn't know how long actions will take to halt, so it lets a timer run for a bit before inputting again. <a href="http://appium.io">http://appium.io</a></p>

<p>Espresso is a white box testing framework. It uses the Android JUnit service to test on your android device/emulator. Because it is connected to the source, it can tell when activities end, so the tests run faster. <a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html">https://google.github.io/android-testing-support-library/docs/espresso/index.html</a></p>

<p>Robolectric is a white box testing framework. It runs the activity lifecycle itself, so it doesn't need a device or emulator. It is also very finicky with imported code, so we haven't gotten it to work yet. <a href="http://robolectric.org">http://robolectric.org</a></p>

<p>Robotium is a white-or-black box testing framework that can record and play back test cases on a device or emulator. It has a whole bunch of customization options for your test cases. <a href="http://robotium.com/pages/user-guide-android-studio">http://robotium.com/pages/user-guide-android-studio</a></p>

<p>UIAutomator is a white-or-black box testing framework that is able to automate across the entire android system, and is good for managing apps in the context of actual usage. It uses the AndroidJUnitRunner test runner. <a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html">https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html</a></p>

<h2>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dependencies</h2>

<ul>
<li>Selenium Client &amp; WebDriver 2.52.0 (Java)</li>
<li>Gson 2.2.4</li>
<li>Appium Java-Client 3.3.0</li>
<li>Appium-Support 1.0.5</li>
<li>JUnit 4.11</li>
<li>Apache Maven 4</li>
</ul>

<h2>
<a id="structure" class="anchor" href="#structure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Structure</h2>

<p>The project is structured into three different parts: JSON Parser, Translation Engine, and Execution Engine</p>

<ol>
<li>The JSON Parser takes in a JSON file. This file contains GUI event commands in the form '&lt;component, action&gt;'. The JSON Parser then parses this file and stores them internally in TestCase,  StepTestCase, and Component objects as actions. </li>
<li>The Translation Engine converts actions into commands specific to different testing frameworks. </li>
<li>Finally, the Execution Engine outputs test cases from those commands. It can:

<ul>
<li>Output a Java source file, which can be directly executed (available for Espresso and Appium)</li>
<li>Execute those commands directly on a physical Android device or emulator (Appium only)</li>
</ul>
</li>
</ol>

<h2>
<a id="extension" class="anchor" href="#extension" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Extension</h2>

<p>To extend the project to work with another framework, you mostly need to implement a translation engine, which you can base off of preexisting abstract classes in the .trans package. Then you must link that engine up to the Main class with with a couple lines of code.</p>

<p>The major function in your engine will be Translator.steps_iterator(TestCase). This function should iterate through the TestCase that has been created from the user's JSON file. Your Translator should pass the actions to a Functions class, which decides between all the actions a user inputs, and places code corresponding to those actions in the toWrite attribute of your Translator.</p>

<p>Then you tell the Translator to print out toWrite in Main (that code's already there).</p>

<p>In Main, you need to add lines in three places. First, import your package up top. Second, add your new classname to the switch statement that currently (4/7/2016) has "Espresso" and "Appium" and such. Put yours at the end, and follow the pattern. The third place is if you have a live mode, in which case you will need to add code to the next switch statement, or handle it more cleverly above. Live mode is more difficult to support overall, since each framework differs more wildly.</p>

<p>For the framework you wish to implement, you will want to create a new folder for your framework in the src directory and add classes to it titled [your_framework]FileModifier.java which extends the FileModifier class, [your_framework]Functions.java which extends the GenericFunctions class, and [your_framework]Translator.java which extends the GenericTranslator abstract class, keeping in line with how the files have been established for the existing frameworks.</p>

<p>Inside each of your framework's translation engine classes you will need to implement ALL the functions inside the FileModifier and Translator classes and AS MANY functions as you possibly can in the Functions class to make the translator as fully functional as you need it to be. You will need to clearly specify all the neccessary imports and other setup jargon in the FileModifier, and know what the appropriate java statements are for your framework to execute specific actions such as clicks, long clicks, typing, and swipes. The StepTestCase iterator will be able to allow you to run through a parsed JSON file to know exactly where to click, or what to type, but in the end, it is up to the implementor to understand how exactly to make these actions occur within the context of their framework. </p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/King-AK/TranslationWMcs435">TranslationEngine</a> is maintained by <a href="https://github.com/King-AK">King-AK</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
