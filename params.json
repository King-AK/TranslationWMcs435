{
  "name": "TranslationEngine",
  "tagline": "Magically converts JSON files to test cases",
  "body": "**<p> College of William and Mary -- CSCI 435 -- TranslationTeam </p>**\r\n<p> <b>TranslationTeam members:</b> Nathan Chen, Avon Davey, Mark Hutchens, Tho Tran</p>\r\n# Purpose\r\n<hr>\r\n\r\n<p>\r\nThe TranslationEngine project was carried out by the TranslationTeam during the Spring 2016 semester at the College of William and Mary as part of the coursework for instructor Denys Poshyvanyk's CSCI 435 course under the supervision of teaching assistant Carlos Bernal-Cardenas. This project aims to automatically generate test cases for various Android graphical user interface (GUI) testing frameworks.\r\n</p>\r\n<p>\r\nTesting software is an important task of software engineering because it assures the quality of the systems that users will use. Moreover, there are different metrics that help to identify whether a software is ready to go to production after executing different tests. In particular for Android applications there are several testing frameworks (e.g. Robotium, Robolectric) that help generate test cases in order to improve the quality of Android applications. However different these frameworks may seem, they are all being used (at least by us) to run automated tests on the same type of graphical interface. Knowing this, we are able to make use of test cases which are more generally described as GUI events in JSON files rather than explicit code for specific frameworks.\r\n</p>\r\n<p>\r\nTherefore, the goal of this project is to generate a translation engine that will take as input a JSON file containing GUI events, and then parse those events into Java code which is executable for several different testing frameworks.\r\n</p>\r\n\r\n# Video Demo\r\nEdit HTML and add Manually at the end\r\n\r\n# Project Overview\r\n\r\n## User Guide\r\nAgain, the purpose of the project is in parsing a JSON file for use with one of several Android testing frameworks.\r\n\r\nOur project manifests itself as simple command line interface (CLI) program. It's fairly easy to use the program, and there is not much of a learning curve when it comes to using the program. \r\nTo use our program you have one of two choices to choose from when it comes to passing in input:\r\n<ul>\r\n<li><b>Following the prompt and entering input when asked.</b> The prompt is very self-explanatory, but we explain things here for completeness. \r\n<ol>\r\n<li>Select a framework to translate to by either entering a number or entering the name of the framework (being sure to be case-sensitive in your input). Selecting a Live Mode will send you down a different chain of input. Scroll further down for more information.</li>\r\n<li>Next, enter the relative path of the JSON file you are parsing from if you are storing your JSON files in the ~/IO folder, do this as \"./IO/[your JSON file name]\". <i>Alternatively</i>, enter the absolute path to the JSON file of choice if it is not local to the project directory</li>\r\n<li>Lastly, enter a name for the output file.</li>\r\n</ol>\r\n</li>\r\n<li><b>Passing a parameter file.</b> To do this, you pass a single parameter, which is the name of a local .txt file holding all of your preferences for the translation. The information in the parameter file is written in the following fashion (it is actually the same ordering as the prompter): \r\n\r\n``Framework, Mode (\"file\"/\"live\"), Input, Output.\r\n(e.g. \"UIAutomator file ./IO/mileage_swipe.txt ./IO/standard_out.txt\" without the quotes)\r\nClick this [link](https://github.com/TranslationWMcs435/TranslationWMcs435/blob/master/Code/IO/preferences.txt) to see one of our preference files as an example.\r\n</li>\r\n</ul>\r\nFor all file creations, you will need to copy-paste the outputted code into your preexisting test framework.\r\n\r\n<b>Live Mode</b>\r\n<i>The only live mode actually integrated at the moment is for Appium.</i> By selecting to convert to a Live mode, you are choosing to execute your JSON test case on the fly with the specified framework instead of receiving output as a file containing Java code. TranslationEngine does this by running through the parsed results of your JSON file line by line and dynamically executing commands that match the selected framework on your emulator or physical device.  \r\n\r\n## Supported frameworks\r\nTranslationEngine currently supports the following testing frameworks: Appium, Espresso, Robotium, and UIAutomator. To make use of these frameworks, you will need to make sure they are installed on your system and ready for use as they would be if you were not using TranslationEngine. For help with that, click [here](https://github.com/TranslationWMcs435/TranslationWMcs435/tree/master/Artifacts/Setup%20instructions).\r\n\r\n<hr>\r\n### Appium\r\n<b>Appium</b> is a <i>black box</i> testing framework. In both live and file mode testing, it will rely upon the creation of a server (handled by the TranslationEngine in Live Mode, and in the output file for file mode) that controls your Android device or emulator remotely. Because this framework does not know how long actions will take to halt (e.g. performing a tap that switches the screen view vs performing a tap that does not change screen view), TranslationEngine will automatically delay the commands it sends to the Android device/emulator. This may make the code appear to run slower than the other frameworks. Learn more about Appium at: http://appium.io\r\n\r\n### Espresso\r\n<b>Espresso</b> is a white box testing framework. It uses the Android JUnit service to test on your android device/emulator. Because it is connected to the source, it can tell when activities end, so the tests run faster. Learn more about Espresso at: https://google.github.io/android-testing-support-library/docs/espresso/index.html\r\n\r\n### Robotium\r\n<b>Robotium</b> is a white-or-black box testing framework that can record and play back test cases on a device or emulator. It has a whole bunch of customization options for your test cases. Learn more about Robotium at: http://robotium.com/pages/user-guide-android-studio\r\n\r\n### UIAutomator\r\n<b>UIAutomator</b> is a white-or-black box testing framework that is able to automate across the entire android system, and is good for managing apps in the context of actual usage. It uses the AndroidJUnitRunner test runner. Learn more about UIAutomator at: https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html\r\n\r\n## Dependencies\r\n - Selenium Client & WebDriver 2.52.0 (Java)\r\n - Gson 2.2.4\r\n - Appium Java-Client 3.3.0\r\n - Appium-Support 1.0.5\r\n - JUnit 4.11\r\n - Apache Maven 4\r\n\r\n## Structure Overview\r\nThe project is structured into three different parts: JSON Parser, Translation Engine, and Execution Engine\r\n\r\n1. The <b>JSON Parser</b> takes in a JSON file. This file contains GUI event commands in the form '&lt;component, action&gt;'. The JSON Parser then parses this file and stores them internally in TestCase,  StepTestCase, and Component objects as actions. \r\n2. The <b>Translation Engine</b> converts actions into commands specific to different testing frameworks. \r\n3. Finally, the <b>Execution Engine</b> outputs test cases from those commands. It can:\r\n\t- Output a Java source file, which can be directly executed (available for Espresso and Appium)\r\n\t- Execute those commands directly on a physical Android device or emulator (Appium only)\r\n\r\n## Extension\r\nTo extend the project to work with another framework, you mostly need to implement a translation engine for that framework. \r\nWe have made this very easy for anyone to do so long as they base their additions on what already exists. This can be done by making use of preexisting abstract classes in the .trans package, and completing the methods as fit for your new framework. \r\nAdditionally, you must link the new engine up to the Main class by adding a couple lines of code to Main.java.\r\n\r\nThe major function in your engine will be Translator.steps_iterator(TestCase). This function should iterate through the TestCase that has been created from the user's JSON file. Your Translator should pass the actions to a Functions class, which decides between all the actions a user inputs, and places code corresponding to those actions in the toWrite attribute of your Translator.\r\nThen you tell the Translator to print out toWrite in Main (that code's already there).\r\n\r\n\r\nFor the framework you wish to implement, you will want to create a new folder for your framework in the src directory and add 3  classes to it:\r\n\r\n1. <b>[your_framework]FileModifier.java</b>, which extends the FileModifier class, \r\n2. <b>[your_framework]Functions.java</b>, which extends the GenericFunctions class, \r\n3. <b>[your_framework]Translator.java</b>, which extends the GenericTranslator abstract class\r\n\r\nThese three classes must exist as a minimum to keep in line with how the engines have been established for the existing frameworks.\r\n\r\nInside each of your framework's translation engine classes you will need to implement ALL the functions inside the FileModifier and Translator classes and AS MANY functions as you possibly can in the Functions class to make the translator as fully functional as you need it to be. You will need to clearly specify all the neccessary imports and other setup jargon in the FileModifier, and know what the appropriate java statements are for your framework to execute specific actions such as clicks, long clicks, typing, and swipes. The StepTestCase iterator will be able to allow you to run through a parsed JSON file to know exactly where to click, or what to type, but in the end, it is up to the implementor to understand how exactly to make these actions occur within the context of their framework. So be sure to at least become semi-familiar with the documentation on any framework you wish to add.\r\n\r\nIn Main.java, you need to add lines in three places: \r\n1. Import your package up top. \r\n2. Add your new framework name to the switch statement that currently has the names of other frameworks such as \"Espresso\" and \"Appium\" and such. Put yours at the end, and follow the pattern, including a number and being case-sensitive. \r\n3. If you have a live mode, add code to the next switch statement (or handle it more cleverly above). Live mode is more difficult to support overall, since each framework differs more wildly.\r\n\r\nThe beauty in this is lies in the fact that as more people use TranslationEngine and add more frameworks, anyone who uses TranslationEngine can create fully functional tests in any supported framework without any deep knowledge of the framework they are creating a test for. They minimally must only be familiar with JSON.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}